# -*- coding: utf-8 -*-
"""DAA_pro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1myBA3OBjBfXu35006T-t4BVF06MC7Sxi
"""

!pip install streamlit
!pip install osmnx
!pip install networkx
!pip install folium

import osmnx as ox
import networkx as nx
import folium
import pandas as pd
from geopy.geocoders import Nominatim
from google.colab import files
from google.colab import drive

# Mount your Google Drive
drive.mount('/content/drive')

# Load the traffic dataset
dataset_path = '/content/drive/MyDrive/bangalore_traffic.csv'  # Change path if your file is elsewhere
traffic_df = pd.read_csv('/content/drive/MyDrive/Dynamic Traffic System/Banglore_traffic_Dataset.csv')

# Display the first few rows
traffic_df.head()

# Load the road network of Bangalore
G = ox.graph_from_place('Bangalore, India', network_type='drive')

# Load the speed data from your dataset (mock example)
# Normally, this would come from a CSV or API â€” here's simulated speed data
speed_data = {
    (u, v): 10 + i % 40  # Random speed pattern between 10 to 50 km/h
    for i, (u, v, k) in enumerate(G.edges(keys=True))
}

# Update edge weights based on speed (travel time = length / speed)
for u, v, k, data in G.edges(keys=True, data=True):
    length_km = data['length'] / 1000  # meters to kilometers
    speed = speed_data.get((u, v), 40)  # default speed if missing
    travel_time = length_km / speed  # hours
    data['travel_time'] = travel_time

# Take input from user for source and destination
source_place = input("Enter the source location in Bangalore: ")
destination_place = input("Enter the destination location in Bangalore: ")

# Convert place names to coordinates
geolocator = Nominatim(user_agent="route_mapper")
source_location = geolocator.geocode(source_place + ", Bangalore")
destination_location = geolocator.geocode(destination_place + ", Bangalore")

# Get nearest nodes from graph
orig_node = ox.distance.nearest_nodes(G, source_location.longitude, source_location.latitude)
dest_node = ox.distance.nearest_nodes(G, destination_location.longitude, destination_location.latitude)

# Shortest path using dataset-based travel time (red path)
path1 = nx.shortest_path(G, orig_node, dest_node, weight='travel_time')
path1_coords = [(G.nodes[node]['y'], G.nodes[node]['x']) for node in path1]

# Create a folium map centered at the source
m = folium.Map(location=[source_location.latitude, source_location.longitude], zoom_start=13)

# Add markers for source and destination
folium.Marker(location=[source_location.latitude, source_location.longitude], popup='Source', icon=folium.Icon(color='green')).add_to(m)
folium.Marker(location=[destination_location.latitude, destination_location.longitude], popup='Destination', icon=folium.Icon(color='red')).add_to(m)

# Draw the dataset-based shortest travel time path (red)
folium.PolyLine(path1_coords, color='red', weight=5, opacity=0.8, tooltip="Traffic-based route").add_to(m)

# Show the map
m.save('bangalore_traffic_route.html')
print("Map has been saved to 'bangalore_traffic_route.html'. Open it in a browser to view.")